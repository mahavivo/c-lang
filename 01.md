## 第1章 导言

在本书的开篇，我们首先概要地介绍 C 语言，主要是通过实际的程序引入 C 语言的基本 元素，至于其中的具体细节、规则以及一些例外情况，在此暂时不多做讨论。因此，本章不 准备完整、详细地讨论 C 语言中的一些技术（当然，这里所举的所有例子都是正确的）。我们 是希望读者能尽快地编写出有用的程序，为此，本章将重点介绍一些基本概念，比如变量与 常量、算术运算、控制流、函数、基本输入／输出等。而对于编写较大型程序所涉及到的一 些重要特性，比如指针、结构、C 语言中十分丰富的运算符集合、部分控制流语句以及标准库 等，本章将暂不做讨论。

这种讲解方式也有缺点。应当提请注意的是，在本章的内容中无法找到任何特定语言特 性的完整说明，并且，由于比较简略，可能会使读者产生一些误解；再者，由于所举的例子 并没有用到 C 语言的所有强大功能，因此，这些例子也许并不简洁、精炼。虽然我们已经尽 力将这些问题的影响降到最低，但问题肯定还是存在。另一个不足之处在于，本章所讲的某 些内容在后续相关章节还必须再次讲述。我们希望这种重复给读者带来的帮助效果远远超过 它的负面影响。

无论是利还是弊，一个经验丰富的程序员应该可以从本章介绍的内容中推知他们自己进 行程序设计所需要的一些基本元素。初学者应编写一些类似的小程序作为本章内容的补充练 习。无论是经验丰富的程序员还是初学者，都可以把本章作为后续各章详细讲解的内容的框架。

### 1.1.	入门

学习一门新程序设计语言的惟一途径就是使用它编写程序。对于所有语言的初学者来说， 编写的第一个程序几乎都是相同的，即：
请打印出下列内容
```
hello, world
```
尽管这个练习很简单，但对于初学语言的人来说，它仍然可能成为一大障碍，因为要实 现这个目的，我们首先必须编写程序文本，然后成功地运行编译，并加载、运行，最后输出 到某个地方。掌握了这些操作细节以后，其它事情就比较容易了。
在 C 语言中，我们可以用下列程序打印出“hello, world”：
```c
#include <stdio.h>

main()
{
	printf("hello, world\n");
}
```
如何运行这个程序取决于所使用的系统。这里举一个特殊的例子。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并以“.c”作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译：
```
cc hello.c
```
如果源程序没有什么错误（例如漏掉字符或拼错字符），编译过程将顺利进行，并生成一个可
执行文件 a.out。然后，我们输入：
```
a.out
```
即可运行 a.out，打印出下列信息：
```
hello, world
```
在其它操作系统中，编译、加载、运行等规则会有所不同。

* * *
```c
#include <stdio.h>             /* 包含标准库的信息 */

main()                         /* 定义名为 main 的函数，它不接受参数值 */
{                              /* main 函数的语句都被括在花括号中 */
    printf("hello, world\n");  /* main 函数调用库函数 printf 以显示字符序列；\n 代表换行符 */
}
```
**第一个 C 语言程序**
* * *

下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortran 语言中的子程序和函数，与 Pascal 语言中的过程和函数也 很类似。在本例中，函数的名字为 main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某 个位置包含一个 main 函数。

main 函数通常会调用其它函数来帮助完成某些工作，被调用的函数可以是程序设计人员自己编写的，也可以来自于函数库。上述程序段中的第一行语句
```c
#include <stdio.h>
```
用于告诉编译器在本程序中包含标准输入／输出库的信息。许多 C 语言源程序的开始处都包含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列 表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因 此用空参数表()表示。

函数中的语句用一对花括号{}括起来。本例中的 main 函数仅包含下面一条语句：
```c
printf("hello, world\n");
```
调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将"hello, world\n"作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处， 它打印双引号中间的字符串。

用双引号括起来的字符序列称为字符串或字符串常量，如"hello, world\n"就是一个
字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。

在 C 语言中，字符序列\n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行的左端行首开始。如果去掉字符串中的\n（这是个值得一做的练习），即使输出打印完成后也 不会换行。在 printf 函数的参数中，只能用\n 表示换行符。如果用程序的换行代替\n，例如：
```c
printf("hello, world
");
```
C 编译器将会产生一条错误信息。

printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。上面给出的第一个程序也可以改写成下列形式：
```c
#include <stdio.h>

main()
{
	printf("hello, ");
	printf("world");
	printf("\n");
}
```
这段程序与前面的程序的输出相同。

请注意，\n 只代表一个字符。类似于\n 的转义字符序列为表示无法输入的字符或不可见字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表 示制表符；\b 表示回退符；\"表示双引号；\\表示反斜杠符本身。2.3 节将给出转义字符序列的完整列表。

**练习 1-1**	在你自己的系统中运行“hello, world”程序。再有意去掉程序中的部分内容，看看会得到什么出错信息。

**练习 1-2**	做个实验，当 printf 函数的参数字符串中包含\c（其中 c 是上面的转义字符序列中未曾列出的某一个字符）时，观察一下会出现什么情况。

1.2.	变量与算术表达式

我们来看下一个程序，使用公式℃=(5/9)(℉-32)打印下列华氏温度与摄氏温度对照表：
```
1    -17
20   -6
40   4
60   15
80   26
100  37
120  48
140  60
160  71
180  82
200  93
220  104
240  115
260  126
280  137
300  148
```
此程序中仍然只包括一个名为 main 的函数定义。它比前面打印“hello, world”的程序
长一些，但并不复杂。这个程序中引入了一些新的概念，包括注释、声明、变量、算术表达式、循环以及格式化输出。该程序如下所示：
```c
#include <stdio.h>

/* 当fahr=0，20，… ，300时，分别
打印华氏温度与摄氏温度对照表 */
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0;      /* 温度表的下限 */
    upper = 300;    /* 温度表的上限 */
    step = 20;      /* 步长 */

    fahr = lower;
    while (fahr <= upper) {
        celsius = 5 * (fahr-32) / 9;
        printf("%d\t%d\n", fahr, celsius);
        fahr = fahr + step;
    }
}
```
其中的两行：
```
/*当 fahr=0，20，… ，300 时，分别
打印华氏温度与摄氏温度对照表 */
```
称为注释，此处，它简单地解释，该程序是做什么用的。包含在/*与*/之间的字符序列将被编译器忽略。注释可以自由地运用在程序中，使得程序更易于理解。程序中允许出现空格、制表符或换行符之处，都可以使用注释。

在 C 语言中，所有变量都必须先声明后使用。声明通常放在函数起始处，在任何可执行语句之前。声明用于说明变量的属性，它由一个类型名和一个变量表组成，例如：
```c
int fahr, celsius;
int lower, upper, step;
```
其中，类型 int 表示其后所列变量为整数，与之相对应的，float 表示所列变量为浮点数（即， 可以带有小数部分的数）。int 与 float 类型的取值范围取决于具体的机器。对于 int 类型，通常为 16 位，其取值范围在-32768～32767 之间，也有用 32 位表示的 int 类型。float 类型通常是 32 位，它至少有 6 位有效数字，取值范围一般在 10-38～1038 之间。

除 int 与 float 类型之外，C 语高还提供了其它一些基本数据类型，例如：
```
char      字符 —— 一个字节
short     短整型
long      长整型
double    双精度浮点型
```
这些数据类型对象的大小也取决于具体的机器。另外，还存在这些基本数据类型的数组、结构、联合，指向这些类型的指针以及返回这些类型值的函教。我们将在后续相应的章节中分别介绍。

在上面的温度转换程序中，最开始执行的计算是下列 4 个赋值语句：
```c
lower = 0;
upper = 300;
step = 20;
fahr = lower;
```
它们为变量设置初值。各条语句均以分号结束。

温度转换表中的各行计算方式相同，因此可以用循环语句重复输出各行。这是 while 循环语句的用途：
```c
while (fahr <= upper) {
...
}
```
while 循环语句的执行方式是这样的：首先测试圆括号中的条件；如果条件为真 (fahr<=upper)，则执行循环体（括在花括号中的 3 条语句）；然后再重新测试圆括号中的条件，如果为真，则再次执行循环体；当圆括号中的条件测试结果为假(fahr>upper)时， 循环结束，并继续执行跟在 while 循环语句之后的下一条语句。在本程序中，循环语句后没有其它语句，因此整个程序的执行终止。

while 语句的循环体可以是用花括号括起来的一条或多条语句（如上面的温度转换程序），也可以是不用花括号包括的单条语句，例如：
```c
while (i < j)
    i = 2 * i;
```
在这两种情况下，我们总是把由 while 控制的语句缩进一个制表位，这样就可以很容易地看出循环语句中包含哪些语句。这种缩进方式突出了程序的逻辑结构。尽管 C 编译器并不关心程序的外观形式，但正确的缩进以及保留适当空格的程序设计风格对程序的易读性非常重要。我们建议每行只书写一条语句，并在运算符两边各加上一个空格字符，这样可以使得运算的结合关系更清楚明了。相比而言，花括号的位置就不那么重要了。我们从比较流行的一些风格中选择了一种，读者可以选择适合自己的一种风格，并养成一直使用这种风格的好习惯。

在该程序中，绝大部分工作都是在循环体中完成的。循环体中的赋值语句
```c
celsius =	5 * (fahr - 32) / 9：
```
用于计算与指定华氏温度相对应的摄氏温度值，并将结果赋值给变量 celsius。在该语句中， 之所以把表达式写成先乘 5 然后再除以 9 而不是直接写成 5 / 9，其原因是在 C 语言及许多其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。由于 5 和 9 都是整数，5 / 9 相除后经截取所得的结果为 0，因此这样求得的所有摄氏温度都将为 0。

从该例子中也可以看出 printf 函数的一些功能。printf 是一个通用输出格式化函数，第 7 章将对此做详细介绍。该函数的第一个参数是待打印的字符串，其中的每个百分号（%） 表示其它的参数（第二个、第三个、……参数）之一进行替换的位置，并指定打印格式。例如，%d 指定一个整型参数，因此语句
```c
printf("%d\t%d\n", fahr, celsius);
```
用于打印两个整数 fahr 与 celsius 的值，并在两者之间留一个制表符的空间（\t）。

printf 函数的第一个参数中的各个%分别对应于第二个、第三个、……参数，它们在数目和类型上都必须匹配，否则将出现错误的结果。

顺便指出，printf 函数并不是 C 语言本身的一部分，C 语言本身并没有定义输入／输出功能。printf 仅仅是标准库函数中一个有用的函数而已，这些标准序函数在 C 语言程序中通常都可以使用。但是，ANSI 标准定义了 printf 函数的行为，因此，对每个符合该标准的编译器和库来说，该函数的属性都是相同的。

为了将重点放到讲述 C 语言本身上，我们在第 7 章之前的各章中将不再对输入／输出做更多的介绍，并且，特别将格式化输入推后到第 7 章讲解。如果读者想了解数据输入，可以先阅读 7.4 节中对 scanf 函数的讨论部分，scanf 函数类似于 printf 函数，但它用于读输入数据而不是写输出数据。

上述的温度转换程序存在两个问题。比较简单的问题是，由于输出的数不是右对齐的，所以输出的结果不是很美观。这个问题比较容易解决：如果在 printf 语句的第一个参数的%d 中指明打印宽度，则打印的数字会在打印区域内右对齐。例如，可以用语句
```c
printf("%3d %6d\n", fahr, celsius);
```
打印 fahr 与 celsius 的值，这样，fahr 的值占 3 个数字宽，celsius 的值占 6 个数字宽， 输出的结果如下所示：
```
0     -17
20	 -6
40	  4
60	 15
80	 26
100    37
...
```
另一个较为严重的问题是，由于我们使用的是整型算术运算，因此经计算得到的摄氏温度值不太精确，例如，与 0℉ 对应的精确的摄氏温度应该为-17.8℃，而不是-17℃。为了得到更精确的结果，应该用浮点算术运算代替上面的整型算术运算。这就需要对程序做适当修改。下面是该程序的又一种版本
```c
#include <stdio.h>

/* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300; floating-point
 * version */

main() {
    float fahr, celsius;
    float lower, upper, step;

    lower = 0;      /* lower limit of temperatuire scale */
    upper = 300;    /* upper limit */
    step = 20;      /* step size */

    fahr = lower;
    while (fahr <= upper) {
        celsius = (5.0/9.0) * (fahr-32.0);
        printf("%3.0f %6.1f\n", fahr, celsius);
        fahr = fahr + step;
    }
}
```
这个程序与前一个程序基本相同，不同的是，它把 fahr 与 celsius 声明为 float 类型，转换公式的表述方式也更自然一些。在前一个程序中，之所以不能使用 5 / 9 的形式， 是因为按整型除法的计算规则，它们相除并舍位后得到的结果为 0。但是，常数中的小数点表明该常数是一个浮点数，因此，5.0 / 9.0 是两个浮点数相除，结果将不被舍位。

如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。例如，在表达式 fahr – 32 中，32 在运算过程中将被自动转换为浮点数再参与运算。不过，即使浮点常量取的是整型值，在书写时最好还是为它加上一个显式的小数点，这样可以强调其浮点性质，便于阅读。

第 2 章将详细介绍把整型数转换为浮点型数的规则。在这里需要注意，赋值语句
```c
fahr = lower;
```
与条件测试语句
```c
while (fahr <= upper)
```
也都是按照这种方式执行的，即在运算之前先把 int 类型的操作数转换为 float 类型的操作数。

printf 中的转换说明 %3.0f 表明待打印的浮点数（即 fahr）至少占 3 个字符宽，且不带小数点和小数部分；%6.1f 表明另一个待打印的数（celsius）至少占 6 个字符宽，且小数点后面有 1 位数字。其输出如下所示：
```
0    -17.8
20    -6.7
40     4.4
...
```
格式说明可以省略宽度与精度，例如，%6f 表示待打印的浮点数至少有 6 个字符宽；%.2f 指定待打印的浮点数的小数点后有两位小数，但宽度没有限制；%f 则仅仅要求按照浮点数打印该数。
```
%d        按照十进制整型数打印
%6d       按照十进制整型数打印，至少 6 个字符宽
%f        按照浮点数打印
%6f       按照浮点数打印，至少 6 个字符宽
%.2f      按照浮点数打印，小数点后有两位小数
%6.2f     按照浮点数打印，至少 6 个字符宽，小数点后有两位小数
```
此外，printf 函数还支持下列格式说明：%o 表示八进制数；%x 表示十六进制数；%c 表示字符；%s 表示字符串；%%表示百分号（%）本身。

**练习 1-3**	修改温度转换程序，使之能在转换表的顶部打印一个标题。

**练习 1-4**	编写一个程序打印摄氏温度转换为相应华氏温度的转换表。

1.3.	for 语句

对于某个特定任务我们可以采用多种方法来编写程序。下面这段代码也可以实现前面的温度转换程序的功能：
```c
#include <stdio.h>

/*打印华氏温度—摄氏温度对照表*/
main() {
    int fahr;

    for (fahr = 0; fahr <= 300; fahr = fahr + 20)
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
}
```
这个程序与上节中介绍的程序执行结果相同，但程序本身却有所不同。最主要的改进在于它去掉了大部分变量，而只使用了一个 int 类型的变量 fahr。在新引入的 for 语句中，温度的下限、上限和步长都是常量，而计算摄氏温度的表达式现在变成了 printf 函数的第三个参数，它不再是一个单独的赋值语句。

以上几点改进中的最后一点是 C 语言中一个通用规则的实例：在允许使用某种类型变量值的任何场合，都可以使用该类型的更复杂的表达式。因为 printf 函数的第三个参数必须是与 %6.1f 匹配的浮点值，所以可以在此处使用任何浮点表达式。

for 语句是一种循环语句，它是对 while 语句的推广。如果将 for 语句与前面介绍的 while 语句比较，就会发现 for 语句的操作更直观一些。圆括号中共包含 3 个部分，各部分 之间用分号隔开。第一部分
```c
fahr = 0
```
是初始化部分，仅在进入循环前执行一次。第二部分
```c
fahr <= 300
```
是控制循环的测试或条件部分。循环控制将对该条件求值，如果结果值为真（true），则执行循环体（本例中的循环体仅包含一个 printf 函数调用语句）。此后将执行第三部分
```c
fahr = fahr + 20
```
以将循环变量 fahr 增加一个步长，并再次对条件求值。如果计算得到的条件值为假（faise），循环将终止执行。与 while 语句一样，for 循环语句的循环体可以只有一条语句，也可以是用花括号括起来的一组语句。初始化部分（第一部分）、条件部分（第二部分）与增加步长部分（第三部分）都可以是任何表达式。

在实际编程过程中，可以选择 whi1e 与 for 中的任意一种循环语句，主要要看使用哪一种更清晰。for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环控制语句集中放在一起，且比 while 语句更紧凑。

**练习 1-5** 修改温度转换程序，要求以逆序（即按照从 300 度到 0 度的顺序）打印温度转换表。

### 1.4.	符号常量

在结束讨论温度转换程序前，我们再来看一下符号常量。在程序中使用 300、20 等类似的“幻数”并不是一个好习惯，它们几乎无法向以后阅读该程序的人提供什么信息，而且使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define 指令可以把符号名（或称为符号常量）定义为一个特定的字符串：
```c
#define 名字 替换文本
```
在该定义之后，程序中出现的所有在 #define 中定义的名字（既没有用引号引起来，也不是其它名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列；替换文本可以是任何字符序列，而不仅限于数字。
```c
#include <stdio.h>

#define LOWER  0     /* lower limit of table */
#define UPPER  300   /* upper limit */
#define STEP   20    /* step size */

/* print Fahrenheit-Celsius table */
main()

    int fahr;

    for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP)
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
}
```
其中，LOWER、UPPER 与 STEP 都是符号常量，而非变量，因此不需要出现在声明中。符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。注意，#define 指令行的末尾没有分号。

### 1.5.	字符输入／输出

接下来我们看一组与字符型数据处理有关的程序。读者将会发现，许多程序只不过是这里所讨论的程序原型的扩充版本而已。

标准库提供的输入／输出模型非常简单。无论文本从何处输入，输出到何处，其输入／输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则由 0 个或多个字符组成，行末是一个换行符。标准库负责使每个输入／输出流都能够遵守这一模型。使用标准库的 C 语言程序员不必关心在程序之外这些行是如何表示的。

标准库提供了一次读／写一个字符的函数，其中最简单的是 getchar 和 putchar 两个函数。每次调用时，getchar 函数从文本流中读入下一个输入字符，并将其作为结果值返回。 也就是说，在执行语句
```c
c = getchar()
```
之后，变量 c 中将包含输入流中的下一个字符。这种字符通常是通过键盘输入的。关于从文件输入字符的方法，我们将在第 7 章中讨论。

每次调用 putchar 函数时将打印一个字符。例如，语句
```c
putchar()
```
将把整型变量 c 的内容以字符的形式打印出来，通常是显示在屏幕上。putchar 与 printf 这两个函数可以交替调用，输出的次序与调用的次序一致。

1.5.1.	文件复制

借助于 getchar 与 putchar 函数，可以在不了解其它输入／输出知识的情况下编写出数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出，其基本思想 如下：
```
读一个字符
while (该字符不是文件结束指示符)
    输出刚读入的字符
    读下一个字符
```
将上述基本思想转换为 C 语言程序为：
```c
#include <stdio.h>

/* copy input to output; 1st version  */
main()
{
    int c;

    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
}
```
其中，关系运算符!=表示“不等于”。

字符在键盘、屏幕或其它的任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。char 类型专门用于存储这种字符型数据，当然任何整型（int）也可以用于存储字符型数据。因为某些潜在的重要原因，我们在此使用 int 类型。

这里需要解决如何区分文件中有效数据与输入结束符的问题。C 语言采取的解决方法是：没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个值称为 EOF（end of file，文件结束）。我们在声明变量 c 的时候，必须让它大到足以存放 getchar 函数返回的任何值。这里之所以不把 c 声明成 char 类型，是因为它必须足够大， 除了能存储任何可能的字符外还要能存储文件结束符 EOF。因此，我们将 c 声明成 int 类型。

EOF 定义在头文件`<stdio.h>`中，是个整型数，其具体数值是什么并不重要，只要它与任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的任何特定的数值。

对于经验比较丰富的 C 语言程序员，可以把这个字符复制程序编写得更精炼一些。在 C 语言中，类似于
```c
c = getchar()
```
之类的赋值操作是一个表达式，并且具有一个值，即赋值后左边变量保存的值。也就是说，赋值可以作为更大的表达式的一部分出现。如果将为 c 赋值的操作放在 while 循环语句的测试部分中，上述字符复制程序便可以改写成下列形式：
```c
#include <stdio.h>

/* copy input to output; 2nd version  */
main()
{
    int c;

    while ((c = getchar()) != EOF)
        putchar(c);
}
```
在该程序中，while 循环语句首先读一个字符并将其赋值给 c，然后测试该字符是否为文件结束标志。如果该字符不是文件结束标志，则执行 while 语句体，并打印该字符。随后重复执行 while 语句。当到达输入的结尾位置时，while 循环语句终止执行，从而整个 main 函数执行结束。

以上这段程序将输入集中化，getchar 函数在程序中只出现了一次，这样就缩短了程序，整个程序看起来更紧凑。习惯这种风格后，读者就会发现按照这种方式编写的程序更易阅读。我们经常会看到这种风格。（不过，如果我们过多地使用这种类型的复杂语句，编写的程序可 能会很难理解，应尽量避免这种情况。）

对 while 语句的条件部分来说，赋值表达式两边的圆括号不能省略。不等于运算符 != 的优先级比赋值运算符 = 的优先级要高，这样，在不使用圆括号的情况下关系测试 != 将在赋值 = 操作之前执行。因此语句
```c
c = getchar() != EOF
```
等价于语句
```c
c = (getchar() != EOF)
```
该语句执行后，c 的值将被置为 0 或 1（取决于调用 getchar 函数时是否碰到文件结束标志），这并不是我们所希望的结果（更详细的内容，请参见第 2 章的相关部分）。

**练习 1-6**	验证表达式 getchar() != EOF 的值是 0 还是 1。

**练习 1-7**	编写一个打印 EOF 值的程序。

1.5.2.	字符计数

下列程序用于对字符进行计数，它与上面的复制程序类似。
```c
#include <stdio.h>
/* count characters in input; 1st version */
main( ) {
    long nc;
    nc = 0;
    while (getchar() 1= EOF)
        ++nc;
    printf ("%ld\n", nc l ;
}
```
其中，语句
```c
++nc;
```
引入了一个新的运算符++，其功能是执行加 1 操作。可以用语句 nc = nc + 1 代替它，但语句++nc 更精炼一些，且通常效率也更高。与该运算符相应的是自减运算符--。++与--这两个运算符既可以作为前缀运算符（如++nc），也可以作为后缀运算符（如 nc++）。我们在第 2 章中将看到，这两种形式在表达式中具有不同的值，但 ++nc 与 nc++ 都使 nc 的值增加 1。 目前，我们只使用前缀形式。

该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数（长整型）至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同，但在一些机器上，int 类型的值可能只有 16 位存储单元的长度（最大值为32767），这样，相当小的输入都可能使 int 类型的计数变量溢出。转换说明 %ld 告诉 printf 函数其对应的参数是 long 整型。

使用 double（双精度浮点数）类型可以处理更大的数字。我们在这里不使用 while 循环语句，而用 for 循环语句来展示编写此循环的另一种方法：
```c
#include <stdio.h>

/* count characters in input; 2nd version */
main()

    double nc;

    for (nc = 0; gechar() != EOF; ++nc)
        ;
    printf("%.0f\n", nc);
}
```
对于 float 与 double 类型。printf 函数都使用 %f 进行说明。%.0f 强制不打印小数点和小数部分，因此小数部分的位数为 0。

在该程序段中，for 循环语句的循环体是空的，这是因为所有工作都在测试（条件）部分与增加步长部分完成了。但 C 语言的语法规则要求 for 循环语句必须有一个循环体，因此用单独的分号代替。单独的分号称为空语句，它正好能满足 for 语句的这一要求。把它单独放在一行是为了更加醒目。

在结束讨论字符计数程序之前，我们考虑以下情况：如果输入中不包含字符，那么，在第一次调用 getchar 函数的时候，while 语句或 for 语句中的条件测试从一开始就为假，程序的执行结果将为 0，这也是正确的结果。这一点很重要。whi1e 语句与 for 语句的优点之一就是在执行循环体之前就对条件进行测试，如果条件不满足，则不执行循环体，这就可能出现循环体一次都不执行的情况。在出现 0 长度的输入时，程序的处理应该灵活一些，在出现边界条件时，while 语句与 for 语句有助于确保程序执行合理的操作。

1.5.3.	行计数

接下来的这个程序用于统计输入中的行数。我们在上面提到过，标准库保证输入文本流
以行序列的形式出现，每一行均以换行符结束。因此，统计行数等价于统计换行符的个数。

#include <stdio.h>

/* count lines in input */ main()
{
int c, nl;

nl = 0;
while ((c = getchar()) != EOF) if (c == '\n')
++nl; printf("%d\n", nl);
}
在该程序中，while 循环语句的循环体是一个 if 语句，它控制自增语句++nl。if 语句 先测试圆括号中的条件，如果该条件为真，则执行其后的语句（或括在花括号中的一组语句）。 这里再次用缩进方式表明语句之间的控制关系。

双等于号==是 C 语言中表示“等于”关系的运算符（类似于 Pascal 中的单等于号=及 Fortran 中的.EQ.）。由于 C 语言将单等于号=作为赋值运算符，因此使用双等于号==表示相等的逻辑 关系，以示区分。这里提醒注意，在表示“等于”逻辑关系的时候（应该用==），C 语言初学 者有时会错误地写成单等于号=。在第 2 章我们将看到，即使这样误用了，其结果通常仍然是 合法的表达式，因此系统不会给出警告信息。

单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称 之为字符常量。但是，它只不过是小的整型数的另一种写法而已。例如，'A'是一个字符常量； 在 ASCII 字符集中其值为 65（即字符 A 的内部表示值为 65）。当然，用'A'要比用 65 好，因 为。'A'的意义更清楚，且与特定的字符集无关。
字符串常量中使用的转义字符序列也是合法的字符常量，比如，'\n'代表换行符的值， 在 ASCII 字符集中其值为 10。我们应当注意到，'\n'是单个字符，在表达式中它不过是一个 整型数而已；而"\n"是一个仅包含一个字符的字符串常量。有关字符串与字符之间的关系， 我们将在第 2 章进一步讨论。
练习 1-8	编写一个统计空格、制表符与换行符个数的程序。
练习 1-9	编写一个将输入复制到输出的程序，并将其中连续的多个空格用一个空格代
替。
练习 1-10	编写一个将输入复制到输出的程序，并将其中的制表符替换为\t，把回退符
替换为\b，把反斜杠替按为\\。这样可以将制表符和回退符以可见的方式显示出来。

1.5.4.	单词计数

我们将介绍的第 4 个实用程序用于统计行数、单词数与字符数。这里对单词的定义比较 宽松，它是任何其中不包含空格、制表符或换行符的字符序列。下面这段程序是 UNIX 系统 中 wc 程序的骨干部分：
#include <stdio.h>

#define IN	1	/* inside a word */
#define OUT	0	/* outside a word */

/* count lines, words, and characters in input */ main()
{
int c, nl, nw, nc, state;

state = OUT;
nl = nw = nc = 0;
while ((c = getchar()) != EOF) {
++nc;
if (c == '\n')
++nl;
if (c == ' ' || c == '\n' || c = '\t') state = OUT;
else if (state == OUT) { state = IN;
++nw;
}
}
printf("%d %d %d\n", nl, nw, nc);
}
程序执行时，每当遇到单词的第一个字符，它就作为一个新单词加以统计。state 变量 记录程序当前是否正位于一个单词之中，它的初值是“不在单词中”，即初值被赋为 OUT。我 们在这里使用了符号常量 IN 与 OUT，而没有使用其对应的数值 1 与 0，这样程序更易读。在 较小的程序中，这种做法也许看不出有什么优势，但在较大的程序中，如果从一开始就这样 做，因此而增加的一点工作量与提高程序可读性带来的好处相比是值得的。读者也会发现， 如果程序中的幻数都以符号常量的形式出现，对程序进行大量修改就会相对容易得多。

下列语句

nl = nw = nc = 0;
将把其中的 3 个变量 nl、nw 与 nc 都设置为 0。这种用法很常见，但要注意这样一个事实：
在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左。所以上面这条语句等同于

n1 = (nw = (nc = 0));
运算符||代表 OR（逻辑或），所以下列语句
if (c == ' ' || c== '\n' || c == '\t')
的意义是“如果 c 是空格，或 c 是换行符，或 c 是制表符”（前面讲过，转义字符序列\t 是 制表符的可见表示形式）。相应地，运算符&&代表 AND（逻辑与），它仅比||高一个优先级。 由&&或||连接的表达式由左至右求值，并保证在求值过程中只要能够判断最终的结果为真或 假，求值就立即终止。如果 c 是空格，则没有必要再测试它是否为换行符或制表符，这样就 不必执行后面两个测试。在这里，这一点并不特别重要，但在某些更复杂的情况下这样做就 有必要了，不久我们将会看到这种例子。

这段程序中还包括一个 else 部分，它指定当 if 语句中的条件部分为假时所要执行的动 作。其一般形式为：
if (表述式)
语句 1
else
语句 2

其中，if-else 中的两条语句有且仅有一条语句被执行。如果表达式的值为真，则执行 语句 1，否则执行语句 2。这两条语句都既可以是单条语句，也可以是括在花括号内的语句序 列。在单词计数程序中，else 之后的语句仍是一个 if 语句，该 if 语句控制了包含在花括 号内的两条语句。
练习 1-11 你准备如何测试单词计数程序？如果程序中存在某种错误，那么什么样的输 入最可能发现这类错误呢’
练习 1-12	编写一个程序，以每行一个单词的形式打印其输入。

1.6.	数组

在这部分内容中，我们来编写一个程序，以统计各个数字、空白符（包括空格符、制表 符及换行符）以及所有其它字符出现的次数。这个程序的实用意义并不大，但我们可以通过 该程序讨论 C 语言多方面的问题。
所有的输入字符可以分成 12 类，因此可以用一个数组存放各个数字出现的次数，这样比 使用 10 个独立的变量更方便。下面是该程序的一种版本：
#include <stdio.h>

/* count digits, white space, others */ main()
{
int c, i, nwhite, nother; int ndigit[10];

nwhite = nother = 0;
for (i = 0; i < 10; ++i) ndigit[i] = 0;

while ((c = getchar()) != EOF) if (c >= '0' && c <= '9')
++ndigit[c-'0'];
else if (c == ' ' || c == '\n' || c == '\t')
++nwhite; else
++nother;

printf("digits =");
for (i = 0; i < 10; ++i) printf(" %d", ndigit[i]);
printf(", white space = %d, other = %d\n", nwhite, nother);
}
当把这段程序本身作为输入时，输出结果为：

digits = 9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345
该程序中的声明语句
int ndigit[10]，
将变量 ndigit 声明为由 10 个整型数构成的数组。在 C 语言中，数组下标总是从 0 开始，因

此该数组的 10 个元素分别为 ndigit[0]、ndiglt[1]、…、ndigit[9]，这可以通过初始 化和打印数组的两个 for 循环语句反映出来。
数组下标可以是任何整型表达式，包括整型变量（如 i）以及整型常量。
该程序的执行取决于数字的字符表示属性。例如，测试语句

if (c >= '0' && c <= '9')
用于判断 c 中的字符是否为数字。如果它是数字，那么该数字对应的数值是 c- '0'
只有当'0'、'1'、…、'9'具有连续递增的值时，这种做法才可行。幸运的是，所有的字符
集都是这样的。

由定义可知，char 类型的字符是小整型，因此 char 类型的变量和常量在算术表达式中 等价于 int 类型的变量和常量。这样做既自然又方便，例如，c - '0'是一个整型表达式， 如果存储在 c 中的字符是'0'～'9'，其值将为 0～9，因此可以充当数组 ndigit 的合法下 标。

判断一个字符是数字、空白符还是其它字符的功能可以由下列语句序列完成：

if (c >= '0' && c <= '9')
++ndigit[c-'0'];
else if (c == ' ' || c == '\n' || c == '\t')
++nwhite; else
++nother;
程序中经常使用下列方式表示多路判定：
if (条件 1)
语句 1
else if (条件 1)
语句 2
...
...
else
语句 n
在这种方式中，各条件从前往后依次求值，直到满足某个条件，然后执行对应的语句部分。 这部分语句执行完成后，整个语句体执行结束（其中的任何语句都可以是括在花括号中的若 干条语句）。如果所有条件都不满足，则执行位于最后一个 else 之后的语句（如果有的话）。 类似于前面的单词计数程序，如果没有最后一个 else 及对应的语句，该语句体将不执行任何 动作。在第一个 if 与最后一个 else 之间可以有 0 个或多个下列形式的语句序列：
else if (条件)
语句
就程序设计风格而言，我们建议读者采用上面所示的缩进格式以体现该结构的层次关系， 否则，如果每个 if 都比前一个 else 向里缩进一些距离，那么较长的判定序列就可能超出页 面的右边界。
第 3 章将讨论的 switch 语句提供了编写多路分支程序的另一种方式，它特别适合于判
定某个整型或字符表达式是否与一个常量集合中的某个元素相匹配的情况。我们将在 3.4 节给

出用 switch 语句编写的该程序的另一个版本，与此进行比较。
练习 1-13	编写一个程序，打印输入中单词长度的直方图。水平方向的直方图比较容易
绘制，垂直方向的直方图则要困难些。
练习 1-14	编写一个程序，打印输入中各个字符出现频度的直方图。

1.7.	函数

C 语言中的函数等价于 Fortran 语言中的子程序或函数，也等价于 Pascal 语言中的过程或 函数。函数为计算的封装提供了一种简便的方法，此后使用函数时不需要考虑它是如何实现 的。使用设计正确的函数，程序员无需考虑功能是如何实现的，而只需知道它具有哪些功能 就够了。在 C 语言中可以简单、方便、高效地使用函数。我们经常会看到在定义后仅调用了 一次的短函数，这样做可以使代码段更清晰易读。
到目前为止，我们所使用的函数（如 printf、getchar 和 putchar 等）都是函数库 中提供的函数。现在，让我们自己动手来编写一些函数。C 语言没有像 Fortran 语言一样提供 类似于**的求幂运算符，我们现在通过编写一个求幂的函数 power(m, n)来说明函数定义 的方法。power(m, n)函数用于计算整数 m 的 n 次幂，其中 n 是正整数。对函数调用 power(2, 5)来说，其结果值为 32。该函数并非一个实用的求幂函数，它只能处理较小的整数的正整数 次幂，但这对于说明问题已足够了。（标准库中提供了一个计算 xy 的函数 pow(x, y)。）
下面是函数 power(m, n)的定义及调用它的主程序，这样我们可以看到一个完整的程序 结构。

#include <stdio.h>

int power(int m, int n);

/* test power function */ main()
{
int i;

for (i = 0; i < 10; ++i)
printf("%d %d %d\n", i, power(2,i), power(-3,i)); return 0;
}

/* power:	raise base to n-th power; n >= 0 */ int power(int base, int n)
{
int i,	p;

p = 1;
for (i = 1; i <= n; ++i) p = p * base;
return p;
}
函数定义的一般形式为：
返回值类型 函数名(0 个或多个参数声明)

{
声明部分
语句序列
}
函数定义可以以任意次序出现在一个源文件或多个源文件中，但同一函数不能分割存放 在多个文件中。如果源程序分散在多个文件中，那么，在编译和加载时，就需要做更多的工 作，但这是操作系统的原因，并不是语言的属性决定的。我们暂且假定将 main 和 power 这 两个函数放在同一文件中，这样前面所学的有关运行 C 语言程序的知识仍然有效。
main 函数在下列语句中调用了两次 power 函数：
printf("%d %d %d\n", i, power(2, i), power(-i, 3));
每次调用时，main 函数向 power 函数传递两个参数；在调用执行完成时，power 函数向 main 函数返回一个格式化的整数并打印。在表达式中，power(2, i)同 2 和 i 一样都是整数（并 不是所有函数的结果都是整型值，我们将在第 4 章中讨论）。
power 函数的第一行语句
int power(int base, int n)
声明参数的类型、名字以及该函数返回结果的类型。power 函数的参数使用的名字只在 power 函数内部有效，对其它任何函数都是不可见的：其它函数可以使用与之相同的参数名字而不 会引起冲突。变量 i 与 p 也是这样：power 函数中的 i 与 main 函数中的 i 无关。
我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形
式参数对应的值称为实际参数。

power 函数计算所得的结果通过 return 语句返回给 main 函数。关键字 return 的后 面可以跟任何表达式，形式为：
return 表达式;
函数不一定都有返回值。不带表达式的 return 语句将把控制权返回给调用者，但不返回有 用的值。这等同于在到达函数的右终结花括号时，函数就“到达了尽头”。主调函数也可以忽 略函数返回的值。

读者可能已经注意到，main 函数的末尾有一个 return 语句。由于 main 本身也是函数， 因此也可以向其调用者返回一个值，该调用者实际上就是程序的执行环境。一般来说，返回 值为 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。为简洁起见，前面 的 main 函数都省略了 return 语句，但我们将在以后的 main 函数中包含 return 语句， 以提醒大家注意，程序还要向其执行环境返回状态。
出现在 main 函数之前的声明语句
int power(int m, int n);
表明 power 函数有两个 int 类型的参数，并返回一个 int 类型的值。这种声明称为函数原 型，它必须与 power 函数的定义和用法一致。如果函数的定义、用法与函数原型不一致，将 出现错误。

函数原型与函数声明中参数名不要求相同。事实上，函数原型中的参数名是可选的，这
样上面的函数原型也可以写成以下形式

int power(int, int);
但是，合适的参数名能够起到很好的说明性作用，因此我们在函数原型中总是指明参数
名。

回顾一下，ANSI C 同较早版本 C 语言之间的最大区别在于函数的声明与定义方式的不同。
按照 C 语言的最初定义，power 函数应该写成下列形式：
/* power:	raise base to n-th power; n >= 0 */
/*	(old-style version) */ power(base, n)
int base, n;
{
int i, p;

p = 1;
for (i = 1; i <= n; ++i) p = p * base;
return p;
}
其中，参数名在圆括号内指定，参数类型在左花括号之前声明。如果没有声明某个参数的类 型，则默认为 int 类型。函数体与 ANSI C 中形式相同。
在 C 语言的最初定义中，可以在程序的开头按照下面这种形式声明 power 函数：
int power();
函数声明中不允许包含参数列表，这样编译器就无法在此时检查 power 函数调用的合法性。 事实上，power 函数在默认情况下将被假定返回 int 类型的值，因此整个函数的声明可以全 部省略。

在 ANSI C 中定义的函数原型语法中，编译器可以很容易检测出函数调用中参数数目和类 型方面的错误。ANSI C 仍然支持旧式的函数声明与定义，这样至少可以有一个过渡阶段。但 我们还是强烈建议读者：在使用新式的编译器时，最好使用新式的函数原型声明方式。
练习 1-15	重新编写 1.2 节中的温度转换程序，使用函数实现温度转换计算。

1.8.    参数——传值调用

习惯其它语言（特别是 Fortran 语言）的程序员可能会对 C 语言的函数参数传递方式感到 陌生。在 C 语言中，所有函数参数都是“通过值”传递的。也就是说，传递给被调用函数的 参数值存放在临时变量中，而不是存放在原来的变量中。这与其它某些语言是不同的，比如， Fortran 等语言是“通过引用调用”，Pascal 则采用 var 参数的方式，在这些语言中，被调用的 函数必须访问原始参数，而不是访问参数的本地副本。
最主要的区别在于，在 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只
能修改其私有的临时副本的值。

传值调用的利大于弊。在被调用函数中，参数可以看作是便于初始化的局部变量，因此 额外使用的变量更少。这样程序可以更紧凑简洁。侧如，下面的这个 power 函数利用了这一 性质：

/* power:	raise base to n-th power; n >= 0; version 2 */ int power(int base, int n)
{
int p;

for (p = 1; n > 0; --n) p = p * base;
return p;
}
其中，参数 n 用作临时变量，并通过随后执行的 for 循环语句递减，直到其值为 0，这样就 不需要额外引入变量 i；power 函数内部对 n 的任何操作不会影响到调用函数中 n 的原始参 数值。

必要时，也可以让函数能够修改主调函数中的变量。这种情况下，调用者需要向被调用 函数提供待设置值的变量的地址（从技术角度看，地址就是指向变量的指针），而被调用函数 则需要将对应的参数声明为指针类型，并通过它间接访问变量。我们将在第 5 章中讨论指针。
如果是数组参数，情况就有所不同了。当把数组名用作参数时，传递给函数的值是数组 起始元素的位置或地址——它并不复制数组元素本身。在被调用函数中，可以通过数组下标 访问或修改数组元索的值。这是下一节将要讨论的问题。

1.9.     字符数组

字符数组是 C 语言中最常用的数组类型。下面我们通过编写一个程序，来说明字符数组 以及操作字符数组的函数的用法。该程序读入一组文本行，并把最长的文本行打印出来。该 算法的基本框架非常简单：
while (还有未处理的行)
if (该行比已处理的最长行还要长) 保存该行为最长行 保存该行的长度
打印最长的行
从上面的框架中很容易看出，程序很自然地分成了若干片断，分别用于读入新行、测试读入 的行、保存该行，其余部分则控制这一过程。
因为这种划分方式比较合理，所以可以按照这种方式编写程序。首先，我们编写一个独 立的函数 getline，它读取输入的下一行。我们尽量保持该函数在其它场台也有用。至少 getline 函数应该在读到文件末尾时返回一个信号；更为有用的设计是它能够在读入文本行 时返回该行的长度，而在遇到文件结束符时返回 0。由于 0 不是有效的行长度，因此可以作为 标志文件结束的返回值。每一行至少包括一个字符，只包含换行符的行，其长度为 1。
当发现某个新读入的行比以前读入的最长行还要长时，就需要把该行保存起来。也就是
说，我们需要用另一个函数 copy 把新行复制到一个安全的位置。
最后，我们需要在主函数 main 中控制 getline 和 copy 这两个函数。以下便是我们编 写的程序：

#include <stdio.h>
#define MAXLINE 1000	/* maximum input line length */

int getline(char line[], int maxline); void copy(char to[], char from[]);

/* print the longest input line */ main()
{
int len;	/* current line length */
int max;	/* maximum length seen so far */ char line[MAXLINE];	/* current input line */
char longest[MAXLINE]; /* longest line saved here */

max = 0;
while ((len = getline(line, MAXLINE)) > 0) if (len > max) {
max = len; copy(longest, line);
}
if (max > 0)	/* there was a line */ printf("%s", longest);
return 0;
}

/* getline:	read a line into s, return length	*/ int getline(char s[],int lim)
{
int c, i;

for (i=0; i < lim-1 && (c=getchar())!=EOF && c!='\n'; ++i) s[i] = c;
if (c == '\n') { s[i] = c;
++i;
}
s[i] = '\0'; return i;
}

/* copy:	copy 'from' into 'to'; assume to is big enough */ void copy(char to[], char from[])
{
int i;

i = 0;
while ((to[i] = from[i]) != '\0')
++i;
}
程序的开始对 getline 和 copy 这两个函数进行了声明，这里假定它们都存放在同一个
文件中。

main 与 getline 之间通过一对参数及一个返回值进行数据交换。在 getline 函数中，
两个参数是通过程序行

int getline(char s[], int lim)
声明的，它把第一个参数 s 声明为数组，把第二个参数 lim 声明为整型，声明中提供数组大
小的目的是留出存储空间。在 getline 函数中没有必要指明数组 s 的长度，这是因为该数组

的大小是在 main 函数中设置的。如同 power 函数一样，getline 函数使用了一个 return 语句将值返回给其调用者。上述程序行也声明了 getline 数的返回值类型为 int。由于函数 的默认返回值类型为 int，因此这里的 int 可以省略。
有些函数返回有用的值，而有些函数（如 copy）仅用于执行一些动作，并不返回值。copy
函数的返回值类型为 void，它显式说明该函数不返回任何值。
getline 函数把字符'\0'（即空字符，其值为 0）插入到它创建的数组的末尾，以标记
字符串的结束。这一约定已被 C 语言采用：当在 C 语言程序中出现类似于

"hello\0"
的字符串常量时，它将以字符数组的形式存储，数组的各元素分别存储字符串的各个字符，
并以'\0'标志字符串的结束。



printf 函数中的格式规范%s 规定，对应的参数必须是以这种形式表示的字符串。copy 函数 的实现正是依赖于输入参数由'\0'结束这一事实，它将'\0'拷贝到输出参数中。（也就是说， 空字符'\0'不是普通文本的一部分。）
值得一提的是，即使是上述这样很小的程序，在传递参数时也会遇到一些麻烦的设计问 题。例如，当读入的行长度大于允许的最大值时，main 函数应该如何处理，getline 函数 的执行是安全的，无论是否到达换行符字符，当数组满时它将停止读字符。main 函数可以通 过测试行的长度以及检查返回的最后一个字符来判定当前行是否太长，然后再根据具体的情 况处理。为了简化程序，我们在这里不考虑这个问题。

调用 getline 函数的程序无法预先知道输入行的长度，因此 getline 函数需要检查是 否溢出。另一方面，调用 copy 函数的程序知道（也可以找出）字符串的长度，因此该函数不 需要进行错误检查。
练习 1-16	修改打印最长文本行的程序的主程序 main，使之可以打印任意长度的输入
行的长度，并尽可能多地打印文本。
练习 1-17	编写一个程序，打印长度大于 80 个字符的所有输入行。
练习 1-18	编写一个程序，删除每个输入行末尾的空格及制表符，并删除完全是空格的
行。
练习 1-19 编写函数 reverse(s)，将字符串 s 中的字符顺序颠倒过来。使用该函数 编写一个程序，每次颠倒一个输入行中的字符顺序。

1.10.	外部变量与作用域

main 函数中的变量（如 line、longest 等）是 main 函数的私自变量或局部变量。由 于它们是在 main 函数中声明的，因此其它函数不能直接访问它们。其它函数中声明的变量也 同样如此。例如，getline 函数中声明的变量 i 与 copy 函数中声明的变量 i 没有关系。函 数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。这也是其它语言

通常把这类变量称为自动变最的原因。以后我们使用“自动变量”代表“局部变量”。（第 4
章将讨论 static 存储类，这种类型的局部变量在多次函数调用之间保持值不变。）
由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不 保留前次调用时的赋值，且在每次进入函数时都要显式为其赋值。如果自动变量没有赋值， 则其中存放的是无效值。
除自动变量外，还可以定义位于所有函数外部的变量，也就是说，在所有函数中都可以 通过变量名访问这种类型的变量（这机制同 Fortran 语言中的 COMMON 变量或 Pascal 语言中 最外层程序块声明的变量非常类似）。由于外部变量可以在全局范围内访问，因此，函数间可 以通过外部变量交换数据，而不必使用参数表。再者，外部变量在程序执行期间一直存在， 而不是在函数调用时产生、在函数执行完毕时消失。即使在对外部变量赋值的函数返回后， 这些变量仍将保持原来的值不变。
外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储 单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时说明其类型。声 明时可以用 extern 语句显式声明，也可以通过上下文隐式声明。为了更详细地讨论外部变 量，我们改写上述打印最长文本行的程序，把 line、longest 与 max 声明成外部变量。这 需要修改这 3 个函数的调用、声明与函数体。
int getline(void); void copy(void);

/* print longest input line; specialized version */ main()
{
int len;
extern int max;
extern char longest[];

max = 0;
while ((len = getline()) > 0) if (len > max) {
max = len; copy();
}
if (max > 0)	/* there was a line */ printf("%s", longest);
return 0;
}

/* getline:	specialized version */ int getline(void)
{
int c, i;
extern char line[];

for (i = 0; i < MAXLINE - 1
&& (c=getchar)) != EOF && c != '\n'; ++i) line[i] = c;
if (c == '\n') { line[i] = c;
++i;
}

line[i] = '\0'; return i;
}

/* copy: specialized version */ void copy(void)
{
int i;
extern char line[], longest[];

i = 0;
while ((longest[i] = line[i]) != '\0')
++i;
}
在该例子中，前几行定义了 main、getline 与 copy 函数使用的几个外部变量，声明 了各外部变量的类型，这样编译程序将为它们分配存储单元。从语法角度看，外部变量的定 义与局部变量的定义是相同的，但由于它们位于各函数的外部，因此这些变量是外部变量。 函数在使用外部变量之前，必须要知道外部变量的名字。要达到该目的，一种方式是在函数
中使用 extern 类型的声明。这种类型的声明除了在前面加了一个关键字 extern 外，其它
方面与普通变量的声明相同。

某些情况下可以省略 extern 声明。在源文件中，如果外部变量的定义出现在使用它的 函数之前，那么在那个函数中就没有必要使用 extern 声明。因此，main、getline 及 copy 中的几个 extern 声明都是多余的。在通常的做法中，所有外部变量的定义都放在源文件的 开始处，这样就可以省略 extern 声明。
如果程序包含在多个源文件中，而某个变量在 file1 文件中定义、在 file2 和 file3 文件中使用，那么在文件 file2 与 file3 中就需要使用 extern 声明来建立该变量与其定 义之间的联系。人们通常把变量和函数的 extern 声明放在一个单独的文件中（习惯上称之 为头文件），并在每个源文件的开头使用#include 语句把所要用的头文件包含进来。后缀 名.h 约定为头文件名的扩展名。例如，标准库中的函数就是在类似于<stdio.h>的头文件中 声明的。更详细的信息将在第 4 章中讨论，第 7 章及附录 B 将讨论函数库。
在上述特别版本中，由于 getline 与 copy 函数都不带参数，因此从逻辑上讲，在源文 件开始处它们的原型应该是 getline()与 copy()。但为了与老版本的 C 语言程序兼容， ANSI C 语言把空参数表看成老版本 C 语言的声明方式，并且对参数表不再进行任何检查。在 ANSI C 中，如果要声明空参数表，则必须使用关键字 void 进行显式声明。第 4 章将对此进 一步讨论。

读者应该注意到，这节中我们在谈论外部变量时谨慎地使用了定义（define）与声明
（declaration）这两个词。“定义”表示创建变量或分配存储单元，而“声明”指的是说
明变量的性质，但并不分配存储单元。

顺便提一下，现在越来越多的人把用到的所有东西都作为外部变量使用，因为似乎这样 可以简化数据的通信——参数表变短了，且在需要时总可以访问这些变量。但是，即使在不 使用外部变量的时候，它们也是存在的。过分依赖外部变量会导致一定的风险，因为它会使 程序中的数据关系模糊不清——外部变量的值可能会被意外地或不经意地修改，而程序的修 改又变得十分困难。我们前面编写的打印最长文本行的程序的第 2 个版本就不如第 1 个版本
好，原因有两方面，其一便是使用了外部变量；另一方面，第 2 个版本中的函数将它们所操
纵的变量名直接写入了函数，从而使这两个有用的函数失去了通用性。

到目前为止，我们已经对 C 语言的传统核心部分进行了介绍。借助于这些少量的语言元 素，我们已经能够编写出相当规模的有用的程序。建议读者花一些时间编写程序作为练习。 下面的几个练习比本章前面编写的程序要复杂一些。
练习 1-20 编写程序 detab，将输入中的制表符替换成适当数目的空格，使空格充满到 下一个制表符终止位的地方。假设制表符终止位的位置是固定的，比如每隔 n 列就会出现一 个制表符终止位。n 应该作为变量还是符号常量呢？
练习 1-21 编写程序 entab，将空格串替换为最少数量的制表符和空格，但要保持单词 之间的间隔不变。假设制表符终止位的位置与练习 1-20 的 detab 程序的情况相同。当使用一 个制表符或者一个空格都可以到达下一个制表符终止位时，选用哪一种替换字符比较好？
练习 1-22 编写一个程序，把较长的输入行“折”成短一些的两行或多行，折行的位置 在输入行的第 n 列之前的最后一个非空格之后。要保证程序能够智能地处理输入行很长以及 在指定的列前没有空格或制表符时的情况。
练习 1-23	编写一个删除 C 语言程序中所有的注释语句。要正确处理带引号的字符串与
字符常量。在 C 语言中，注释不允许嵌套。
练习 1-24 编写一个程序，查找 C 语言程序中的基本语法错误，如圆括号、方括号、花 括号不配对等。要正确处理引号（包括单引号和双引号）、转义字符序列与注释。（如果读者 想把该程序编写成完全通用的程序，难度会比较大。）
