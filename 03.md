## 第3章 控制流

程序语言中的控制流语句用于控制各计算操作执行的次序。在前面的例子中，我们曾经使用了一些最常用的控制流结构。本章将更详细地讲述控制流语句。

### 3.1.  语句与程序块

在 x = 0、i++或 printf(...)这样的表达式之后加上一个分号（;），它们就变成了 语句。例如：
```c
x = 0;
i++;
printf(...);
```
在 C 语言中，分号是语句结束符，而 Pascal 等语言却把分号用作语句之间的分隔符。

用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句（也叫作程序块），复合语句在语法上等价于单条语句。函数体中被花括号括起来的语句便是明显一例。if、else，while 与 for 之后被花括号括住的多条语句也是类似的例子。（在任何程序块中都可以声明变量，笫 4 章将对此进行讨论。）右花括号用于结束程序块，其后不需要分号。

### 3.2.  if-else 语句

if-else 语句用于条件判定，其语法如下所示：
```c
if {表达式}
    语句 1
else
    语句 2
```
其中 else 部分是可选的。该语句执行时，先计算表达式的值，如果其值为真（即表达式的值为非 0），则执行语句 1；如果其值为假（即表达式的值为 0），并且该语句包含 else 部分，则执行语句 2。

由于 if 语句只是简单测试表达式的数值，因此可以对某些代码的编写进行简化。最明显的例子是用如下写法
```c
if (表达式)
```
来代替
```c
if (表达式 !0)
```
某些情况下这种形式是自然清晰的，但也有些情况下可能会含义不清。

因为 if-else 语句的 else 部分是可选的，所以在嵌套的 if 语句中省略它的 else 部分将导致歧义。解决的方法是将每个 else 与最近的前一个没有 else 配对的 if 进行匹配。

例如，在下列语句中：
```c
if (n > 0)
    if (a > b)
        z = a;
    else
        z = b;
```
else 部分与内层的 if 匹配，我们通过程序的缩进结构也可以看出来。如果这不符合我们的意图，则必须使用花括号强制实现正确的匹配关系：
```c
if (n > 0) {
    if (a > b)
        z = a;
}
else
    z = b;
```
歧义性在下面这种情况下尤为有害：
```c
if (n > 0)
    for (i = 0; i < n; i++)
        if (s[i] > 0) {
            printf("...");
            return i;
        }
else        /* WRONG */
    printf("error -- n is negative\n");
```
程序的缩进结构明确地表明了设计意图，但编译器无法获得这一信息，它会将 else 部分与内层的 if 配对。这种错误很难发现，因此我们建议在有 if 语句嵌套的情况下使用花括号。

顺便提醒读者注意，在语句
```c
if (a > b)
    z = a;
else
    z = b;
```
中，z = a 后有一个分号。这是因为，从语法上讲，跟在 if 后面的应该是一条语句，而像“z=a;”这类的表达式语句总是以分号结束的。

### 3.3.	else-if 语旬

在 C 语言中我们会经常用到下列结构：
```c
if (表达式)
    语句
else if (表达式)
    语句
else if (表达式)
    语句
else if (表达式)
    语句
else
    语句
```
因此我们在这里单独说明一下。这种 if 语句序列是编写多路判定最常用的方法。其中的各表达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，并终止整个语句序列的执行。同样，其中各语句既可以是单条语句，也可以是用花括号括住的复合语句。

最后一个 else 部分用于处理“上述条件均不成立”的情况或默认情况，也就是当上面各条件都不满足时的情形。有时候并不需要针对默认情况执行显式的操作，这种情况下，可以 把该结构末尾的
```c
else
    语句
```
部分省略掉；该部分也可以用来检查错误，以捕获“不可能”的条件。

这里通过一个折半查找函数说明三路判定程序的用法。该函数用于判定已排序的数组 v 中是否存在某个特定的值 x。数组 v 的元素必须以升序排列。如果 v 中包含 x，则该函数返回 x 在 v 中的位置（介于 0～n-1 之间的一个整数）；否则，该函数返回-1。

在折半查找时，首先将输入值 x 与数组 v 的中间元素进行比较。如果 x 小于中间元素的值，则在该数组的前半部分查找；否则，在该数组的后半部分查找。在这两种情况下，下一步都是将 x 与所选部分的中间元素进行比较。这个过程一直进行下去，直到找到指定的值或 查找范围为空。
```c
/* binsearch:  find x in v[0] <= v[1] <= ... <= v[n-1] */
int binsearch(int x, int v[], int n)
{
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low <= high) {
        mid = (low+high)/2;
        if (x < v[mid])
            high = mid + 1;
        else if (x  > v[mid])
            low = mid + 1;
        else    /* found match */
            return mid;
    }
    return -1;   /* no match */
}
```
该函数的基本判定是：在每一步判断 x 小于、大于还是等于中间元素 v[mid]。使用 else-if 结构执行这种判定很自然。

**练习** 3-1 在上面有关折半查找的例子中，while 循环语句内共执行了两次测试，其实只要一次就足够（代价是将更多的测试在循环外执行）。重写该函数，使得在循环内部只执行一次测试。比较两种版本函数的运行时间。

### 3.4.	switch 语句

switch 语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分支动作。
```c
switch (表达式) {
    case 常量表达式: 语句序列
    case 常量表达式: 语句序列
    default: 语句序列
```
每一个分支都由一个或多个整数值常量或常量表达式标记。如果某个分支与表达式的值匹配，则从该分支开始执行。各分支表达式必须互不相同。如果没有哪一分支能匹配表达式，则执行标记为 default 的分支。default 分支是可选的。如果没有 default 分支也没有其它分支与表达式的值匹配，则该 switch 语句不执行任何动作。各分支及 default 分支的排列次 序是任意的。

我们在第 1 章中曾用 if…else if…else 结构编写过一个程序以统计各个数字、空白符及其它所有字符出现的次数。下面我们用 switch 语句改写该程序如下：
```c
#include <stdio.h>

main()  /* count digits, white space, others */
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF) {
        switch (c) {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            ndigit[c-'0']++;
            break;
        case ' ':
        case '\n':
        case '\t':
            nwhite++;
            break;
        default:
            nother++;
            break;
        }
    }
    printf("digits =");
    for (i = 0; i < 10; i++)
        printf(" %d", ndigit[i]);
    printf(", white space = %d, other = %d\n",
        nwhite, nother);
    return 0;
}
```
break 语句将导致程序的执行立即从 switch 语句中退出。在 switch 语句中，case 的作用只是一个标号，因此，某个分支中的代码执行完后，程序将进入下一分支继续执行，除非在程序中显式地跳转。跳出 switch 语句最常用的方法是使用 break 语句与 return 语句。break 语句还可强制控制从 while、for 与 do 循环语句中立即退出，对于这一点，我们稍后还将做进一步介绍。

依次执行各分支的做法有优点也有缺点。好的一面是它可以把若干个分支组合在一起完成一个任务，如上例中对数字的处理。但是，正常情况下为了防止直接进入下一个分支执行，每个分支后必须以一个 break 语句结束。从一个分支直接进入下一个分支执行的做法并不健全，这样做在程序修改时很容易出错。除了一个计算需要多个标号的情况外，应尽量减少从一个分支直接进入下一个分支执行这种用法，在不得不使用的情况下应该加上适当的程序注释。

作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后面也加上一个 break 语句。这样做在逻辑上没有必要，但当我们需要向该 switch 语句后添加其它分支时，这种防范措施会降低犯错误的可能性。

**练习 3-2** 编写一个函数 escape(s, t)，将字符串 t 复制到字符串 s 中，并在复制过程中将换行符、制表符等不可见字符分别转换为\n、\t 等相应的可见的转义字符序列。要求使用 swich 语句。再编写一个具有相反功能的函数，在复制过程中将转义字符序列转换为实际字符。

### 3.5.	while 循环与 for 循环

我们在前面已经使用过 while 与 for 循环语句。在 while 循环语句
```c
while (表达式)
    语句
```
中，首先求表达式的值。如果其值非 0，则执行语句，并再次求该表达式的值。这一循环过程一直进行下去，直到该表达式的值为 0 为止，随后继续执行语句后面的部分。
```c
for 循环语句;
for (表达式 1; 表达式 2; 表达式 3)
    语句
```
它等价于下列 while 语句：
```c
表达式 1;
while (表达式 2) {
    语句
    表达式 3;
}
```
但当 while 或 for 循环语句中包含 continue 语句时，上述二者之间就不一定等价了。我们将在 3.7 节中介绍 continue 语句。

从语法角度看，for 循环语句的 3 个组成部分都是表达式。最常见的情况是，表达式 1 与表达式 3 是赋值表达式或函数调用，表达式 2 是关系表达式。这 3 个组成部分中的任何部分都可以省略，但分号必须保留。如果在 for 语句中省略表达式 1 与表达式 3，它就退化成了 while 循环语句。如果省略测试条件，即表达式 2，则认为其值永远是真值，因此，下列 for 循环语句：
```c
for (;;) {
    ...
}
```
是一个“无限”循环语句，这种语句需要借助其它手段（如 break 语句或 return 语句）才能终止执行。

在设计程序时到底选用 while 循环语句还是 for 循环语句，主要取决于程序设计人员的个人偏好。例如，在下列语句中：
```c
while ((c = getchar()) == ' ' || c == '\n' || c = '\t')
    ;   /* skip white space characters */
```
因为其中没有初始化或重新初始化的操作，所以使用 whi1e 循环语句更自然一些。

如果语句中需要执行简单的初始化和变量递增，使用 for 语句更合适一些，它将循环控制语句集中放在循环的开头，结构更紧凑、更清晰。通过下列语句可以很明显地看出这一点：
```c
for (i = 0; i < n; i++)
    ...
```
这是 C 语言处理数组前 n 个元素的一种习惯性用法，它类似于 Fortran 语言中的 DO 循环或 Pascal 语言中的 for 循环。但是，这种类比并不完全准确，因为在 C 语言中，for 循环语句的循环变量和上限在循环体内可以修改，并且当循环因某种原因终止后循环变量 i 的值仍然保留。因为 for 语句的各组成部分可以是任何表达式，所以 for 语句并不限于通过算术级数进行循环控制。尽管如此，牵强地把一些无关的计算放到 for 语句的初始化和变量递增部分是一种不好的程序设计风格，该部分放置循环控制运算更合适。

作为一个较大的例子，我们来重新编写将字符串转换为对应数值的函数 atoi。这里编写的函数比第 2 章中的 atoi 函数更通用，它可以处理可选的前导空白符以及一个可选的加（+） 或减（-）号。（第 4 章将介绍函数 atof，它用于对浮点数执行同样的转换。）

下面是程序的结构，从中可以看出输入的格式：
```
如果有空白符的话，则跳过
如果有符号的话，则读取符号
取整数部分，并执行转换
```
其中的每一步都对输入数据进行相应的处理，并为下一步的执行做好准备。当遇到第一个不能转换为数字的字符时，整个处理过程终止。
```c
#include <ctype.h>

/* atoi:  convert s to integer; version 2 */
int atoi(char s[])
{
    int i, n, sign;

    for (i = 0; isspace(s[i]); i++)  /* skip white space */
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')  /* skip sign */
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
    return sign * n;
}
```
标准库中提供了一个更完善的函数 strtol，它将字符串转换为长整型数。有关函数 strtol的详细信息，请参见附录 B.5 节。

把循环控制部分集中在一起，对于多重嵌套循环，优势更为明显。下面的函数是对整型数组进行排序的 Shell 排序算法。Shell 排序算法是 D. L. Shell 于 1959 年发明的，其基本思想是：先比较距离远的元素，而不是像简单交换排序算法那样先比较相邻的元素。这样可以快速减少大量的无序情况，从而减轻后续的工作。被比较的元素之间的距离逐步减少，直到减少为 1，这时排序变成了相邻元素的互换。
```c
/* shellsort:  sort v[0]...v[n-1] into increasing order */
void shellsort(int v[], int n)
{
    int gap, i, j, temp;

    for (gap = n/2; gap > 0; gap /= 2)
        for (i = gap; i < n; i++)
            for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) {
                temp = v[j];
                v[j] = v[j+gap];
                v[j+gap] = temp;
            }
}
```
该函数中包含一个三重嵌套的 for 循环语句。最外层的 for 语句控制两个被比较元素之间的距离，从 n/2 开始，逐步进行对折，直到距离为 0。中间层的 for 循环语句用于在元素间移动位置。最内层的 for 语句用于比较各对相距 gap 个位置的元素，当这两个元素逆序时把它们互换过来。由于 gap 的值最终要递减到 1，因此所有元素最终都会位于正确的排序位置上。注意，即使最外层 for 循环的控制变量不是算术级数，for 语句的书写形式仍然没有变，这就说明 for 语句具有很强的通用性。

逗号运算符“,”也是 C 语言优先级最低的运算符，在 for 语句中经常会用到它。被逗号分隔的一对表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。这样，在 for 循环语句中，可以将多个表达式放在各个语句成分中，比如同时处理两个循环控制变晕。我们可以通过下面的函数 reverse(s)来举例。该函数用于倒置字符串 s 中各个字符的位置。
```c
#include <string.h>

/* reverse:  reverse string s in place */
void reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
```
某些情况下的逗号并不是逗号运算符，比如分隔函数参数的逗号，分隔声明中变量的逗号等，这些逗号并不保证各表达式按从左至右的顺序求值。

应该慎用逗号运算符。逗号运算符最适用于关系紧密的结构中，比如上面的 reverse 函数内的 for 语句，对于需要在单个表达式中进行多步计算的宏来说也很适合。逗号表达式还适用于 reverse 函数中元素的交换，这样，元素的交换过程便可以看成是一个单步操作。
```c
for (i = 0, j = strlen(s)-1; i < j; i++, j--)
    c = s[i], s[i] = s[j], s[j] = c;
```
**练习 3-3**	编写函数 expand(s1, s2)，将字符串 s1 中类似于 a-z 一类的速记符号在字符串 s2 中扩展为等价的完整列表 abc…xyz。该函数可以处理大小写字母和数字，并可以处理 a-b-c、a-z0-9 与-a-z 等类似的情况。作为前导和尾随的-字符原样排印。

### 3.6.	do-while 循环

我们在第 1 章中曾经讲过，while 与 for 这两种循环在循环体执行前对终止条件进行测试。与此相反，C 语言中的第三种循环——do-while 循环则在循环体执行后测试终止条件，这样循环体至少被执行一次。

do-while 循环的语法形式如下：
```c
do
    语句
while (表达式);
```
在这一结构中，先执行循环体中的语句部分，然后再求表达式的值。如果表达式的值为真，则再次执行语句，依此类推。当表达式的值变为假，则循环终止。除了条件测试的语义不同外，do-while 循环与 Pascal 语言的 repeat-until 语句等价。

经验表明，do-while 循环比 while 循环和 for 循环用得少得多。尽管如此，do-while 循环语句有时还是很有用的，下面我们通过函数 itoa 来说明这一点。itoa 函数是 atoi 函数的逆函数，它把数字转换为字符串。这个工作比最初想像的要复杂一些。如果按照 atoi 函数中生成数字的方法将数字转换为字符串，则生成的字符串的次序正好是颠倒的，因此，我们首先要生成反序的字符串，然后再把该字符串倒置。
```c
/* itoa:  convert n to characters in s */
void itoa(int n, char s[])
{
    int i, sign;

    if ((sign = n) < 0)  /* record sign */
        n = -n;          /* make n positive */
    i = 0;
    do {      /* generate digits in reverse order */
        s[i++] = n % 10 + '0';  /* get next digit */
    } while ((n /= 10) > 0);    /* delete it */
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}
```
这里有必要使用 do-while 语句，至少使用 do-while 语句会方便一些，因为即使 n 的值为 0，也至少要把一个字符放到数组 s 中。其中的 do-while 语句体中只有一条语句，尽管没有必要，但我们仍然用花括号将该语句括起来了，这样做可以避免草率的读者将 while 部分误认为是另个 while 循环的开始。

**练习 3-4**  在数的对二的补码表示中，我们编写的 itoa 函数不能处理最大的负数，即 n 等于-2 字长-1 的情况。请解释其原因。修改该函数，使它在任何机器上运行时都能打印出正确的值。

**练习 3-5**	编写函数 itob(n, s, b)，将整数 n 转换为以 b 为底的数，并将转换结果以字符的形式保存到字符串 s 中。例如，itob(n, s, 16)把整数 n 格式化成十六进制整数保存在 s 中。

**练习 3-6**  修改 itoa 函数，使得该函数可以接收三个参数。其中，第三个参数为最小字段宽度。为了保证转换后所得的结果至少具有第三个参数指定的最小宽度，在必要时应在所得结果的左边填充一定的空格。

### 3.7.	break 语句与 continue 语句

不通过循环头部或尾部的条件测试而跳出循环，有时是很方便的。break 语句可用于从 for、while 与 do-while 等循环中提前退出，就如同从 switch 语句中提前退出一样。break 语句能使程序从 switch 语句或最内层循环中立即跳出。

下面的函数 trim 用于删除字符串尾部的空格符、制表符与换行符。当发现最右边的字符为非空格符、非制表符、非换行符时，就使用 break 语句从循环中退出。
```c
/* trim:  remove trailing blanks, tabs, newlines */
int trim(char s[])
{
    int n;

    for (n = strlen(s)-1; n >= 0; n--)
        if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
            break;
    s[n+1] = '\0';
    return n;
}
```
strlen 函数返回字符串的长度。for 循环从字符串的末尾开始反方向扫描寻找第一个不是空格符、制表符以及换行符的字符。当找到符合条件的第一个字符，或当循环控制变量 n 变为负数时（即整个字符串都被扫描完时），循环终止执行。读者可以验证，即使字符串为空或仅包含空白符，该函数也是正确的。

continue 语句与 break 语句是相关联的，但它没有 break 语句常用。continue 语句用于使 for、while 或 do-while 语句开始下一次循环的执行。在 while 与 do-while 语句中，continue 语句的执行意味着立即执行测试部分；在 for 循环中，则意味着使控制转移到递增循环变量部分。continue 语句只用于循环语句，不用于 switch 语句。某个循环包含的 switch 语句中的 continue 语句，将导致进入下一次循环。

例如，下面这段程序用于处理数组 a 中的非负元素。如果某个元素的值为负，则跳过不处理。
```c
for (i = 0; i < n; i++)
    if (a[i] < 0)   /* skip negative elements */
        continue;
    ... /* do positive elements */
```
当循环的后面部分比较复杂时，常常会用到 continue 语句。这种情况下，如果不使用 continue 语句，则可能需要把测试颠倒过来或者缩进另一层循环，这样做会使程序的嵌套更深。

3.8.	goto 语句与标号

C 语言提供了可随意滥用的 goto 语句以及标记跳转位置的标号。从理论上讲，goto 语句是没有必要的，实践中不使用 goto 语句也可以很容易地写出代码。至此，本书中还没有使用 goto 语句。

但是，在某些场合下 goto 语句还是用得着的。最常见的用法是终止程序在某些深度嵌套的结构中的处理过程，例如一次跳出两层或多层循环。这种情况下使用 break 语句是不能达到目的的，它只能从最内层循环退出到上一级的循环。下面是使用 goto 语句的一个例子：
```c
    for ( ... )
        for ( ... ) {
            ...
            if (disaster)
                goto error;
        }
    ...
error:
    /* clean up the mess */
```
在该例子中，如果错误处理代码很重要，并且错误可能出现在多个地方，使用 goto 语句将会比较方便。

标号的命名同变量命名的形式相同，标号的后面要紧跟一个冒号。标号可以位于对应的 goto 语句所在函数的任何语句的前面。标号的作用域是整个函数。

我们来看另外一个例子。考虑判定两个数组 a 与 b 中是否具有相同元素的问题。一种可能的解决方法是：
```c
    for (i = 0; i < n; i++)
        for (j = 0; j < m; j++)
            if (a[i] == b[j])
                goto found;
    /* didn't find any common element */
    ...
found:
    /* got one: a[i] == b[j] */
    ...
```
所有使用了 goto 语句的程序代码都能改写成不带 goto 语句的程序，但可能会增加一些额外的重复测试或变量。例如，可将上面判定是否具有相同数组元素的程序段改写成下列形式：
```c
found = 0;
for (i = 0; i < n && !found; i++)
    for (j = 0; j < m && !found; j++)
        if (a[i] == b[j])
            found = 1;
if (found)
    /* got one: a[i-1] == b[j-1] */
    ...
else
    /* didn't find any common element */
    ...
```
大多数情况下，使用 goto 语句的程序段比不使用 goto 语句的程序段要难以理解和维护，少数情况除外，比如我们前面所举的几个例子。尽管该问题并不太严重，但我们还是建议尽可能少地使用 goto 语句。
